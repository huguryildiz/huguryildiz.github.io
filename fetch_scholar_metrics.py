#!/usr/bin/env python3
"""
fetch_scholar_metrics.py
========================
Fetches citation metrics from Google Scholar (via `scholarly`) and/or
OpenAlex, then writes them to _data/scholar_metrics.yml for use in Jekyll.

Usage
-----
    pip install scholarly requests pyyaml
    python fetch_scholar_metrics.py

Then commit the updated _data/scholar_metrics.yml.
You can also automate this with a GitHub Actions cron job (see bottom of file).

Configuration
-------------
Set SCHOLAR_ID and OPENALEX_ID below.
"""

import json
import datetime
import sys
from pathlib import Path

# ── Configuration ─────────────────────────────────────────────────────────────
SCHOLAR_ID   = "nQwHS1gAAAAJ"          # Your Google Scholar profile ID
OPENALEX_ID  = "A5085505896"           # Your OpenAlex author ID
OUTPUT_FILE  = Path("_data/scholar_metrics.yml")
USE_OPENALEX_FALLBACK = True           # Fall back to OpenAlex if Scholar fails
# ──────────────────────────────────────────────────────────────────────────────


def fetch_from_scholar(scholar_id: str) -> dict:
    """Fetch metrics from Google Scholar using the `scholarly` library."""
    try:
        from scholarly import scholarly
        print("[scholarly] Fetching Google Scholar profile...")
        author = scholarly.search_author_id(scholar_id)
        author = scholarly.fill(author, sections=["basics", "indices", "counts"])

        cites_by_year = author.get("cites_per_year", {})
        # Sort and keep last 8 years
        cites_by_year = dict(
            sorted(cites_by_year.items(), key=lambda x: x[0])[-8:]
        )

        return {
            "source":        "Google Scholar",
            "citations":     author.get("citedby", 0),
            "h_index":       author.get("hindex", 0),
            "i10_index":     author.get("i10index", 0),
            "cites_by_year": cites_by_year,
        }
    except Exception as e:
        print(f"[scholarly] Failed: {e}")
        return {}


def fetch_from_openalex(openalex_id: str) -> dict:
    """Fetch metrics from OpenAlex API (free, no key required)."""
    try:
        import requests
        print("[OpenAlex] Fetching author profile...")
        url = f"https://api.openalex.org/authors/{openalex_id}"
        headers = {"User-Agent": "academic-metrics-fetcher/1.0"}
        r = requests.get(url, headers=headers, timeout=15)
        r.raise_for_status()
        data = r.json()

        stats = data.get("summary_stats", {})
        cby_raw = data.get("counts_by_year", [])

        # Keep last 8 years, sort ascending for chart rendering
        cites_by_year = {
            str(item["year"]): item["cited_by_count"]
            for item in sorted(cby_raw, key=lambda x: x["year"])[-8:]
        }

        return {
            "source":        "OpenAlex",
            "citations":     data.get("cited_by_count", 0),
            "h_index":       stats.get("h_index", 0),
            "i10_index":     stats.get("i10_index", 0),
            "cites_by_year": cites_by_year,
        }
    except Exception as e:
        print(f"[OpenAlex] Failed: {e}")
        return {}


def write_yaml(data: dict, path: Path):
    """Write metrics dict to a simple YAML file (no PyYAML dependency)."""
    path.parent.mkdir(parents=True, exist_ok=True)
    today = datetime.date.today().isoformat()

    lines = [
        f"# Auto-generated by fetch_scholar_metrics.py — do not edit manually",
        f"# Last updated: {today}",
        f"",
        f"source:     \"{data['source']}\"",
        f"updated:    \"{today}\"",
        f"citations:  {data['citations']}",
        f"h_index:    {data['h_index']}",
        f"i10_index:  {data['i10_index']}",
        f"",
        f"cites_by_year:",
    ]
    for year, count in sorted(data["cites_by_year"].items()):
        lines.append(f"  \"{year}\": {count}")

    path.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"[OK] Metrics written to {path}")
    print(f"     Citations : {data['citations']}")
    print(f"     h-index   : {data['h_index']}")
    print(f"     i10-index : {data['i10_index']}")
    print(f"     Source    : {data['source']}")
    print(f"     Updated   : {today}")


def main():
    metrics = fetch_from_scholar(SCHOLAR_ID)

    if not metrics and USE_OPENALEX_FALLBACK:
        print("[info] Falling back to OpenAlex...")
        metrics = fetch_from_openalex(OPENALEX_ID)

    if not metrics:
        print("[ERROR] Could not fetch metrics from any source.")
        sys.exit(1)

    write_yaml(metrics, OUTPUT_FILE)


if __name__ == "__main__":
    main()


# ══════════════════════════════════════════════════════════════════════════════
# OPTIONAL: GitHub Actions automation
# ══════════════════════════════════════════════════════════════════════════════
#
# Create: .github/workflows/update_metrics.yml
#
# name: Update Citation Metrics
#
# on:
#   schedule:
#     - cron: '0 6 * * 1'   # Every Monday at 06:00 UTC
#   workflow_dispatch:        # Allow manual trigger
#
# jobs:
#   update:
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v4
#       - uses: actions/setup-python@v5
#         with: { python-version: '3.11' }
#       - run: pip install scholarly requests
#       - run: python fetch_scholar_metrics.py
#       - uses: stefanzweifel/git-auto-commit-action@v5
#         with:
#           commit_message: "chore: auto-update citation metrics"
#           file_pattern: "_data/scholar_metrics.yml"
#
# ══════════════════════════════════════════════════════════════════════════════